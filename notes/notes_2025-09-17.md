# Meeting Notes, 2025-09-17

1. How do I (or the user) discover all of the command line options (for example, —config doesn’t show up with —help).

Command line options are tied to components and their state. Can set via command line, YAML, etc. Undocumented options (not doc or tip). Not showing -config is a bug. TODO: Open issue in GitHub. Michael wants to go through list. --help is special. Intended to have help component but never materialized.


2. What are the various mechanisms for getting help? Is there something equivalent to `--help-components`? Are any of the following routines accessed via command line arguments? Which ones are intended for high-level use?



    ```python
    pyre_help() - your hook to implement custom information.
    pyre_showSummary() - hook to show text with general description (shows up every time help gets called)
    pyre_showBehaviors() - implementation things, where aspects of report get generated; does not tell default. Will need to override to show default values, location of setting. Further drilling down is not yet implemented.
    pyre_renderTraitValues()
    pyre_showConfiguration()
    pyre_renderConfiguration()
    ```

locator and priority.

trait descriptor; get back slot (locator, value, priority).

Configuration sources have priorities. Command line highest priority. Application configuration files are next; user configuration files; system configuration files; defaults.

Will be moving to instance@type instead of type#instance.

3. In using the executive to set the application name, how does the user set the name (e.g., from the command line)? I assume the intended use is for users to be able to define the name of the application. Is this correct?

    ```python
    #name = pyre.executive.nameserver.get(name="sim", default="sim")
    app = PyLithApp(name="pylith")
    ```



nameserver: actually hiearchical object sim.solver.interpolation.n_steps=4. If given component name, then it creates a separate tree. More than just a dictionary of dictionaries (hashes and links).

If using PyLith as library, user must override application name in script. Provided by driver script that instantiates application (name=pylith).

TODO: Need to register pylith namespace in top level __init__.py.

  register_package()

  Causes pylith.yml file to be loaded.

4. What is a good way to print the full configuration hierarchy? Is there a way to dump a configuration built programmatically to a CFG or YAML file? Likewise, how does one programmatically load a configuration from a YML file and add/change parameters?

    `app.pyre_showConfiguration(deep=True)` does not go into a list of objects.

    TODO: Open issue in Pyre GitHub.

5. How does a user turn on catching configuration errors? For example, setting values using the wrong property name (`xvalue` instead of `value`).

  Argument against: Could have configuration for additional components. Restricts to current seen, not what might see.

  How to catch typos: pyre_configured() gets called on application. Default is to do nothing. Correct implementation is to check for close matches in current loaded configuration. Need command line option to invoke this expensive check.

    TODO: Open feature request.

1. How do I pass multiple configuration files (CFG, YAML) files as command line arguments? --config=FILENAME1,FILENAME2?

  Should be implemented.

7. How do I run the application on 2 processes using MPI?

    ````bash
    ./test_skeleton.py --metadata.author=Joe --shell=mpi.mpirun
    pyre.components.exceptions.ResolutionError: could not resolve 'mpi.mpirun' into a component that implements protocol 'pyre.shells'
    ```

  Michael will make an example.

  Pyre assumes following with mpi application. Some logic of worker versus launcher.

8. How does a user control the journal output (activate/deactivate, set the decor value, change the device) from the command line or YAML files?

  TODO: Open feature request (in progress).

9.  To help users, I am interested in a journal registry to keep track of available journals and allow users to request a list (screen dump, output, etc) of available journals. What are your thoughts on this? Are there any gotchas?

  Component based channels are a mistake. Too narrow. Aspect programming. Collection of correct ideas for journal. Event driven application, solver, etc. 

  Design a journal channel. Can ask which channels have been activated.
  Collect channels for application.
  
  pyre_journalSections() creates list of channels exposed to users.

  journal has detail level. Can also add metadata.

10. Style: What is the best way to separate the protocol from an abstract base class that provides some basic implementation? For example, use `Problem` for the protocol and `ProblemBase` for the abstract base class?

Yes. ProblemBase can implement default behavior and then "implements". Child classes then do not need "implements". Can use NotImplementedError() in ProblemBase to force implementation in child classes.

11. Style: should modules import using the lowercase names defined in `__ini__.py` or the case names defined in the Python class files?

    ```python
    # In another PyLith module - probably not
    from pylith.boundary_conditions.Dirichlet import Dirichlet
    # In module in same directory - yes
    from .Dirichlet import Dirichlet
    # or
    # Allows __init__ control how `dirichlet` is made.
    from pylith.boundary_conditions import dirichlet
    ```

12. What is a good way to define names to avoid clashes between module names and Pyre component names?

    ```python
    from pylith.metadata import features as meta_features

    class Simulation(component, family="pylith.metadata.simulation", implements=Metadata)

        features = meta_features()
        features.doc = "Simulation features"
    ```

protocol family names should be plural nouns and component family names should be singular.

13. Remind me what `plexus` is? My notes from our previous meeting are cryptic. What are the intended use cases?

One step up from raw application. Driver called foo and foo has multifunctioanlity. Categories of command line options. --foo means something different for command `one` versus command `two`.

qed is an application that is plexus drive. Visualization tool driven by GUI.

info, config, about, debug: every plexus application has

qed about
qed about version
qed about copyright
qed about credits

qed info (host, platform, user, help)

qed debug (nfs)

virtual file system

