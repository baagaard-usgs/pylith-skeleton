# Notes

1. Does Pyre preserve the order of component attributes? That is, does `cls.pyre_localTraits()` preserve order?

    Yes, within a component. Shadowing traits. Iterates over each "class" traits, ordered by insertion order.

    See Component.py:

    ```python
    pyre_inheritedTraits()
    Pyre_localTraits()
    ```

2. Within the `pylith` package, should I only use relative imports to prevent circular imports?

    ```python
    # Most files have
    import pylith

    # Full path
    from pylith.materials import elasticity

    # Relative path
    from ...materials import elasticity
    ```

    Use same rules to Python and C++. Public interface (Python __init__.py) at every level do same thing. public.h header file. typedef all classes that are user visible. See pyre/grid.h.

3. Should I import everything in `__init__.py` or just the files in the local directory (not the subdirectories)?

    When import pylith. Downside is circular imports and slowness.

    Advantage: Teach users not to poke inside PyLith. Whatever they are likely to want, everything is accessible in __init__.py. Major downside is pylance does not do dynamic evaluation of __init__.py (will get lots of red squiggles).

    Michael is contemplating making pylance happy or waiting for pylance to "fix" this.

    Pyre __init__.py from `Component import Component as component`. 
    Decorator foundry. Its job is to register that function as discoverable way to instantiate a component without having to import.
    Not just look at attributes that derive from component but also looks for foundries (Foundry).
    Implemented for Python 2, before importlib.

4. Journal still seems to be using just application as the tag, not application (channel). I could not find this update in the journal pull request.

    Journal now uses debug and firewall use Channel name. Info, warning, and error are user facing.

    TODO: Make an issue. DONE

    Python 3.13+ parsing of docstrings is differently, so generated help may be different (will lose blank line at the end).

5. How do I get "colored" journal output on macOS?

    Fix $TERM (currently linux, why?)
    $TERM=xterm-256color or vt102 vt100 ansi
    packages/pyre/shells/Terminal.py (canonical implementation)
    packages/journal/ANSI.py (journal copy for those not using Pyre)

    Journal C++ implementation has full xterm color database.

6. What is a good "Pyre" way to organize components based on physics?

    Elasticity, incompressible elasticity, and poroelasticity each have auxiliary subfields, derived subfields, and solver options.
  
    Grouped by physics with containers in same file.

    I like this approach because it is clear which files need to be added when implementing a new governing equation or bulk rheology.
    It is also relatively compact and filenames are unique.

    ```text
    pylith/materials
      Elasticity.py (Elasticity, AuxiliarySubfields, DerivedSubfields)
      IncompressibleElasticity.py
      Poroelasticity.py
    pylith/materials/elasticity_rheologies
      IsotropicLinear.py (IsotropicLinear, AuxiliarySubfields, DerivedSubfields)
    ```
  
    pylith/materials/elasticity

    At materials level need a foundry.

    ```python
    @pylith.foundry
    def elasticity()
      from .elasticity_eqn import Material
      return Material
    ```

    Users must be able to come to the table with their own materials.
    Family names.

    Grouped by physics with containers in separate files.

    ```text
    pylith/materials
      Material.py

    pylith/materials/elasticity (Material has auxiliary_subfields, derived_subfields)
      Material.py (family=pylith.materials.elasticity.material)  
      BulkRheology.py (protocol=pylith.materials.elasticity.bulk_rheology)
      AuxiliarySubfields.py (family=pylith.materials.elasticity.auxiliary_subfields)
      DerivedSubfields.py (family=pylith.materials.elasticity.derived_subfields)
    pylith/materials/elasticity/isotropic_linear
      BulkRheology.py (family=pylith.materials.elasticity.isotropic_linear)
      AuxiliarySubfields.py (family=pylith.materials.elasticity.isotropic_linear.auxiliary_subfields)
      DerivedSubfields.py (family=pylith.materials.elasticity.isotropic_linear.derived_subfields)
    ```
    
7. What is the best way to provide defaults for a component based on its family name? What is required for this to work? Does `import pylith` need to provide `pylith.governing_eqns.elasticity` or can it be imported using`import pylith.governing_eqns.elasticity`?

    ```python
    class Elasticity(pylith.component, implements=GoverningEqn, family="pylith.governing_eqns.elasticity"):

        solver = solver(default=solver_elasticity_nofault)
    ```

    Parameters using component hierarchy:

    ```yaml
    pylith.app.problem.governing_eqn.solver:
        petsc_options:
            solver:
                - pc_type: gamg
    ```

    ```yaml
    For class defaults, must use family name.
    FAMILY.ATTRIBUTE: abc

    Parameters using family name (only works in some cases)

    ```yaml
    pylith.governing_eqns.elasticity:
        solver.petsc_options.solver:
            - pc_type: gamg
    ```

8. Is naming a component supposed to override settings via the hierarchy:

    ```yaml
    # Parameters via hierarchy
    pylith.app.problem.governing_eqn.solver.petsc_options:
      initial_guess:
        enabled: True
        options:
          - ksp_guess_type, pod
          - ksp_guess_pod_size,  8

    # This prevents the above settings from being used.
    This is a singleton.
    pylith.app:
      problem: pylith.problems.time_dependent#static_problem



    class Application(pylith.application, family="pylith.app"):
      problem = pylith.protocols.problem()

    # This is a way to make problem.
    pylith.app.problem: pylith.problems.time_dependent

    brian.problem: pylith.problems.time_dependent#static_problem
    ```

    ```yaml
    # Singleton
    FAMILY.ATTRIBUTE: FAMILY#NAME

    # Instance with name
    COMPONENT.ATTRIBUTE: FAMILY#NAME
    ```

    TODO: Build a test case. Bug or user error.

    TODO: Move all protocols to a directory to avoid circular imports.

9. `mm` does not appear to be building the Pyre mpi package. I have MPI installed in `/software/baagaard/openmpi-5.0/gcc-11.4/`.

    - pylith/governing_eqns
      - GoverningEqn (protocol=pylith.governing_eqns)
      - elasticity_eqn
        - ElasticityEqn (family=pylith.governing_eqns.elasticity)
        - bulk_rheologies
          - ElasticityRheology (protocol=pylith.governing_eqns.elasticity_eqn.bulk_rheologies)
          - IsotropicLinear (family=pylith.governing_eqns.elasticity_eqn.bulk_rheologies.isotropic_linear)
