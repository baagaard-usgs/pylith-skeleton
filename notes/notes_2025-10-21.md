# Notes

## Journal

1. journal output has the form `NAME: message`. The name seems to come from the name of the application. How is it set? Should it be customized in a library?

    If you don't instantiate a application, then journal's name is `journal`. Intent is to give name for `journal` output and differentiate from other output.

    pyre.shells.Application.py in its constructor (line 178) calls journal.application with string. Forces metadata to be included with output.

    TODO: Can we override the application name with the channel name. Custom version?

    .line(VECTOR)

    Python and C++ both use same global state.

2. If I have an object (class) that reuses the same journal channel in multiple places, is it worth creating a class attribute/member? Where should it be created? A class attribute has the name "journal" the first time it is used, and then the application name for remaining uses.

    Typically no. Michael is slowly removing it from his implementations.

    Timers and journals have global state and channels.

3. Should I use `self.pyre_name` in the journal message? Is there a better way to include the Pyre name in the journal output?

    Yes! print(self) to get name and family name. To get family self.pyre_family() (class method).

4. Are there any built in mechanisms to limit journal output to MPI process 0 or do I need to do something like `if 0 == rank: info.log(msg)`?

    journal is not MPI aware. We must do this explicitly. Much easier to do in Python. See Pyre mpi.

    Keep PETSc in its own communicator (not COMM_WORLD).

    Global rank is never used. First create communicators. Move away from COMM_WORLD. Want to be able to send diagnostics back to comm 0.

## Plexus

1. What is the proper way to setup a Plexus application for running a simulation? Do I create a Run object that has methods for running the application?

    Can mark one as the "default" and if no subcommand is given, it is run. qed does not have a default. Current default is help.

    Main dispatcher in Pylith main().

    Override Plexus.main(). If not argv: self.run() etc.

## Python notebooks

1. Is it possible to load a configuration file programmatically in a Python script with an application?

    ```python
    import pyre

    # republish pyre in pylith.__init__ (see qed)

    pyre.loadConfiguration(uri="FILENAME") # (will turn filename into uri)
    # Generates event indicating state has changed

    pyre.executive.loadConfiguration(uri="FILENAME", locator, priority)
    # locators are in pyre.tracking
    # priorities are in pyre.framework (priority.py)
    # priority is a pair (category, collation number) 

    app = pylith_app(name="pylith.app")
    #app.loadConfiguration("static.yaml") (poor choice; could be a bug if app is not getting updated)
    app.run()
    ```

    Python YAML does not remember comments. Ruamel fork of C YAML has roundtrip parser.

## Pyre/pybind11 integration

1. In what Pyre method should I call the C++ constructor and accessors? pyre_initialized()?

    Earliest you can cal C++ constructor is when there are values for constructor arguments.
    Do it in __init__() of component. Avod pyre.configured() and pyre_initialized().

    Talk more with Michael about inheritance and constructors.

    If the Python object is useless without C++, then inherit from pybind11 bindings.

    Avoid inheritance if want to be able to intervene.

    OO: Are you one of those or do you have one of those?

2. I need to deallocate all PETSc data structures before PetscFinalize() is called. Should I do this in pyre_finalized()?

   - I don't see pyre_finalized() being called. - could be repurposed for PyLith use.
   - If I call PetscFinalize() in the application pyre_finalized(), will all of the components' pyre_finalized() be called first?

    If you use Pyre mpi module, then MPI finalized gets called.

    Create own mechanism for deallocating and calling PetscFinalize().

## Pyre design and complex parameters

1. Our solver parameters depend on the governing equation. We want to have defaults that can be overwritten by the user. Is there a way to load a YAML file based on selected components while honoring user parameters (don't overwrite something specified by the user)?

    YAML files loaded programmatically have lowest priority.

    When given class a family name, defaults are overwritten by parameters.

    Family name in parameter modifies class attributes.

## Introduce a `GoverningEquation` object

- `PyLithApp`
  - `Problem`
    - `GoverningEquation`
      - solution
      - materials
      - boundary_conditions
      - interfaces
      - Object provides PETSc defaults

        pyre_configured() use to verify configuration (generator that returns a list of errors; yield from super() and yield any discovered errors). yield an exception object (carry stack trace with them).

        pyre_initialized() gets called right after constructor is called. Can do more expensive checks.

        All subcomponents are already initialized.
