# Notes

## Configuration

1. I want to set defaults for the mesh initialization phases in `mesh_initializers.MeshInitializer` and allow them to be overwritten by the user. I have put the values in `serial_phases.yaml`. This is an application (not user) configuration file. How do I load it?

By the time the constructor of the parent has been called, the children's constructor has been called and they have been instantiated. It doesn't quite happen that way.

parent.child.value evaluated left to right (parent.getattr("child") -> forces child to be made and then makes sure .value is available)

Load configuration file before setting state. Want hook "about to configure component". Parent should load configuration file.

    ```python
    def pyre_staged(self, **kwds)

        # Create etc (or share) $prefix/etc/pylith (bin/../etc)
        # Currently searchers for etc (garbage; etc->share) and var (lock files)
        pyre.loadConfiguration("serial-phases.yaml")

        return super().pyre_staged(**kwds)
    ```

2. Similar to #1, but I want to add to a list of PETSc options based upon use of a component or a user flag.

    Create configuration settings and if your name is BLAH, TYPE#NAME, conditional configuration setting if both TYPE and NAME match.

    Put settings in `$prefix/etc`.

    # pylith.yaml (first; package; DO THIS) or pylith.app.yaml (when app instance is configured)
    ```yaml
    FAMILY#NAME:
    "FAMILY # NAME":
    pylith.solvers.solver#elasticity_solver:
      petsc_options:
         - 
    ```


    ```yaml
    pylith.app.petsc_options:
        testing: True
    ```

    ```python
    # pylith.petsc.options.OptionsManager
    if self.testing:
        pyre.loadConfiguration("petsc-testing.yaml")
    ```

    ```yaml
    # petsc-testing.yaml
    pylith.app.petsc_options.values:
      # Use different key (options-testing?) if we are appending manually to avoid overwriting?
      - malloc
      - malloc_debug
      - malloc_dump
    ```

3. Similar to #1, but the configuration (solver) settings depend on whether there are any faults.

    ```yaml
    # solver-elasticity-fault.yaml
    pylith/problem.goerning_eqns.elasticity.solver.petsc_options:
        - ts_type, beuler
        - pc_type, gamg

        - dm_reorder_section, True
        - dm_reorder_section_type, cohesive

        - pc_gamg_coarse_eq_limit, 200
        - mg_fine_pc_type, vpbjacobi
        - mg_fine_ksp_max_it, 5
        - mg_levels_pc_type, pbjacobi

    # solver-elasticity.yaml
    pylith/problem.goerning_eqns.elasticity.solver.petsc_options:
        - ts_type, beuler
        - pc_type, gamg

        - pc_gamg_coarse_eq_limit, 200
        - mg_fine_ksp_max_it, 5
        - mg_levels_pc_type, pbjacobi
    ```

4. Similar to #3.

    Don't hold hand to much. Don't want to get too constrained.
    Force human make correct set of choices and validate input!

    ```python
    # pylith/governing_eqns/Elasticity.py
    if len(self.interior_interfaces):
        pyre.loadConfiguration("solution-elasticity-faults.yaml")
    else:
        pyre.loadConfiguration("solution-elasticity.yaml")
    ```

    ```yaml
    # solution-elasticity-faults.yaml
    pylith.problem.governing_eqns.elasticity.solution:
        - pylith.solution_fields.displacement#displacement
        - pylith.solution_fields.velocity#velocity
        - pylith.solution_fields.lagrange_multiplier_fault#lagrange_multiplier_fault

    # solution-elasticity.yaml
    pylith.problem.governing_eqns.elasticity.solution:
        - pylith.solution_fields.displacement#displacement
        - pylith.solution_fields.velocity#velocity
    ```

5. What is the relationship between the family name for a component and the name in __init__? In understand why it is nice that they match, but must they be the same?

    ```python
    # pylith/problems.__init__.py
    from pylith.problems.TimeDependent import TimeDependent as time_dependent

    # pylith/problems/TimeDependent.py
    class TimeDependent(pylith.protocol, implements=Problem, family="pylith.problems.time_dependent"):
    ```

6. We want to specify a default output directory and root for output files. What Pyre features might help with this?

PyLith output directory, make sure directories exist.
Virtual nodes on file system (inject foreign; like symbolic links; like mounting filesystems). 

Pyre vfs. Underlying implementation. Works whether in memory, cloud, filesystem. Could mount HDF5 file inside HDF5 (does not work yet).

Create canonical structure.
`pyre/filesystem/FileSystem`, Local.py.

## Pyre

1. What is a good way to layout the code when we expect only 1 implementation of a protocol?

Leaving behind a facility which is created by protocol.
_Could_ have protocol built on the fly.

```python

```

## Code review

1. `shells/Plexus.py`
2. `cli/Run.py`
3. `mesh_initializers/MeshInitializer.py`
4. `mesh_initializers/phases/MeshRefiner.py`


## Things to revisit

0. journal tag: application(channel) [error, warning, info]
1. React app
...
3. What is a good way to layout the code when we expect only 1 implementation of a protocol?